{"total":29,"pageSize":5,"pageCount":6,"data":[{"title":"01_嵌入式系统概述","slug":"ARM/01_嵌入式系统概述","date":"2018-02-01T06:00:15.000Z","updated":"2018-10-21T09:32:44.947Z","comments":true,"path":"api/articles/ARM/01_嵌入式系统概述.json","excerpt":"<p><strong>1 嵌入式的概念</strong> √<br><strong>2 嵌入式系统的特点</strong> √<br><strong>3 嵌入式系统的组成</strong> √<br><strong>4 ARM内核种类</strong> √<br><strong>5 ARM内核内部的寄存器</strong> √</p>","keywords":null,"cover":null,"content":null,"text":"1 嵌入式的概念 √<br>2 嵌入式系统的特点 √<br>3 嵌入式系统的组成 √<br>4 ARM内核种类 √<br>5 ARM内核内部的寄存器 √前言我对于ARM的学习是基于ARM公司 CotexA9 架构处理器核心 samsung（三星公司） 提供的一款型号为 Exyno","link":"","raw":null,"photos":[],"categories":[{"name":"嵌入式","slug":"嵌入式","count":3,"path":"api/categories/嵌入式.json"}],"tags":[{"name":"ARM","slug":"ARM","count":1,"path":"api/tags/ARM.json"}]},{"title":"02_kernel配置与编译","slug":"kernel/02_kernel配置与编译","date":"2017-10-16T09:53:24.000Z","updated":"2018-10-21T08:50:01.612Z","comments":true,"path":"api/articles/kernel/02_kernel配置与编译.json","excerpt":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>配置编译内核，怎么管理这个大工程，首先内核包含了不同领域的硬件驱动，一开始下载的内核不能直接使用，默认的内核选择的驱动、架构、编译模式与当前环境不同，而且不使用的驱动不需要编译（裁剪很重要，成本很重要）。</p>","keywords":null,"cover":null,"content":null,"text":"简介：配置编译内核，怎么管理这个大工程，首先内核包含了不同领域的硬件驱动，一开始下载的内核不能直接使用，默认的内核选择的驱动、架构、编译模式与当前环境不同，而且不使用的驱动不需要编译（裁剪很重要，成本很重要）。根据执行的硬件环境配置内核移植配置在内核代码根目录执行 make me","link":"","raw":null,"photos":[],"categories":[{"name":"KERNEL","slug":"KERNEL","count":2,"path":"api/categories/KERNEL.json"}],"tags":[{"name":"kernel Linux","slug":"kernel-Linux","count":2,"path":"api/tags/kernel-Linux.json"}]},{"title":"01_kernel目录结构","slug":"kernel/01_kernel目录结构","date":"2017-10-16T00:14:27.000Z","updated":"2018-10-21T08:49:41.966Z","comments":true,"path":"api/articles/kernel/01_kernel目录结构.json","excerpt":"<h1 id=\"简介：\"><a href=\"#简介：\" class=\"headerlink\" title=\"简介：\"></a>简介：</h1><p>此文章简述<code>linux-kernel</code>目录层结构</p>","keywords":null,"cover":null,"content":null,"text":"简介：此文章简述linux-kernel目录层结构1<br>2<br>3<br>4<br>5<br>内核的源码获取<br>\t最新的内核源码：<br>\t\twww.kernel.org<br>\t历史版本内核源码：<br>\t\thttps://www.kernel.org/pub/<br","link":"","raw":null,"photos":[],"categories":[{"name":"KERNEL","slug":"KERNEL","count":2,"path":"api/categories/KERNEL.json"}],"tags":[{"name":"kernel Linux","slug":"kernel-Linux","count":2,"path":"api/tags/kernel-Linux.json"}]},{"title":"08_C++对C的扩展-终","slug":"C++/08_C++对C的扩展-终","date":"2017-04-19T12:58:03.000Z","updated":"2018-04-23T16:19:15.427Z","comments":true,"path":"api/articles/C++/08_C++对C的扩展-终.json","excerpt":"<p><strong>1  C++语言对C语言扩充和增强的几点具体体现</strong> √<br><strong>2 C语言register关键字—最快的关键字</strong> √</p>","keywords":null,"cover":null,"content":null,"text":"1  C++语言对C语言扩充和增强的几点具体体现 √<br>2 C语言register关键字—最快的关键字 √一. C++语言对C语言扩充和增强的几点具体体现1 更加灵活的变量说明在传统的语言中，局部支量的说明必须集中放在执行代码的前面（早期C标准），数据说明语句和执行语句的混合","link":"","raw":null,"photos":[],"categories":[{"name":"面向对象编程","slug":"面向对象编程","count":8,"path":"api/categories/面向对象编程.json"}],"tags":[{"name":"Cpp对C的扩展","slug":"Cpp对C的扩展","count":8,"path":"api/tags/Cpp对C的扩展.json"}]},{"title":"07_C++对C的函数扩展","slug":"C++/07_C++对C的函数扩展 ","date":"2017-04-18T07:20:56.000Z","updated":"2018-05-06T16:24:18.845Z","comments":true,"path":"api/articles/C++/07_C++对C的函数扩展 .json","excerpt":"<p><strong>1 inline内联函数</strong> √<br><strong>2 默认参数</strong> √<br><strong>3 函数占位参数</strong> √<br><strong>4 默认参数和占位参数</strong> √<br><strong>5 函数重载（Overroad）</strong> √</p>","keywords":null,"cover":null,"content":null,"text":"1 inline内联函数 √<br>2 默认参数 √<br>3 函数占位参数 √<br>4 默认参数和占位参数 √<br>5 函数重载（Overroad） √一. inline内联函数C++中的const常量可以替代宏常数定义，如：<br>const int A = 3;  #d","link":"","raw":null,"photos":[],"categories":[{"name":"面向对象编程","slug":"面向对象编程","count":8,"path":"api/categories/面向对象编程.json"}],"tags":[{"name":"Cpp对C的扩展","slug":"Cpp对C的扩展","count":8,"path":"api/tags/Cpp对C的扩展.json"}]}]}