{"title":"bootrom流程","slug":"UBOOT/BOOTROM流程","date":"2018-05-23T05:34:06.000Z","updated":"2018-09-15T04:26:59.792Z","comments":true,"path":"api/articles/UBOOT/BOOTROM流程.json","photos":[],"link":"","excerpt":"BootRom是固化在芯片内部的一段代码，用于引导启动UBOOT，是开机启动的最重要阶段。","covers":null,"content":"<p>BootRom是固化在芯片内部的一段代码，用于引导启动UBOOT，是开机启动的最重要阶段。</p>\n<a id=\"more\"></a>\n<p>1.首先判断<code>boot</code>的启动模式（<code>BOOTMODE_BASE   0X00 60 18 08</code> ）<br>  取低二位返回（三种模式两位数据即可）</p>\n<hr>\n<p>当模式为3时 启用<code>FLASH_BOOT</code><br>1.初始化 <code>spi filsh</code><br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define inw(reg)\t\t(*((volatile unsigned int *) (reg)))</span><br><span class=\"line\">/*</span><br><span class=\"line\">*  volatile修饰的是变化量故此 </span><br><span class=\"line\">*  ((volatile unsigned int)(*((unsigned int *) (reg))))</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">将PIN0_MUX_BASE(0x00 60 18 24)内的值</span><br><span class=\"line\">23~21位置为 011（PIN23(GPIO7)-DO   MUX CFG)</span><br><span class=\"line\">27~24位置为 011（PIN24(GPIO8)-DI   MUX CFG)\t</span><br><span class=\"line\">29~27位置为 011（PIN25(GPIO9)-HOLD MUX CFG)\t</span><br><span class=\"line\"></span><br><span class=\"line\">将PIN1_MUX_BASE(0x00 60 18 28)内的值</span><br><span class=\"line\">03~00位置为 011（PIN26(GPIO10)-WP  MUX CFG)</span><br><span class=\"line\">06~03位置为 011（PIN27(GPIO11)-CLK MUX CFG)\t</span><br><span class=\"line\">09~06位置为 011（PIN28(GPIO12)-CS0 MUX CFG)\t</span><br><span class=\"line\"></span><br><span class=\"line\">/*使能时钟*/</span><br><span class=\"line\">CLK_ENABLE(CLK_SPI_FLASH | CLK_SPI_FLASH_AHB);</span><br><span class=\"line\">CLK_ENBASE (0x00 60 18 0c) 第3位和第15位置1</span><br></pre></td></tr></table></figure></p>\n<p>2.芯片检查</p>\n<blockquote>\n<p>获取芯片码并将低八位置一写回<br>判断spirom是否可以读取成功不成功证明芯片有问题，结束flash_boot并返回1</p>\n</blockquote>\n<p>3.检查<code>spi-flash</code>版本号</p>\n<blockquote>\n<p>用<code>spi</code>向<code>flash</code>发送指令读取<code>flash</code>的标签版本号，将<code>SPI-FLASH</code>中以<code>ENV_FLASH_BASE(0x0)</code>为起点大小为<code>0X100(256B)</code>的数据存入数据区<code>(DLM)</code>的内存顶部<code>(EDLM_BASE + EDLM_SIZE - ENV_INFO_SIZE)</code><br>判断之前的标签是否为”TS8266”如果是，则错误，结束flash_boot并返回1</p>\n</blockquote>\n<p>4.<code>CRC</code>校验</p>\n<blockquote>\n<p>成功时执行加载SPI-FLASH中的UBOOT到内存中，失败时结束flash_boot并返回1</p>\n</blockquote>\n<p>5.获取到<code>UBOOT</code>函数地址并以函数指针形式调用</p>\n<p>当flash_boot返回1时启用UART_BOOT</p>\n<hr>\n<p>当模式为2时 启用<code>UART_BOOT</code></p>\n<p>专用结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_boot</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> time_count;  <span class=\"comment\">//生存时间的记录由10000 * 120递减</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tempBuf[CFG_MSG_SIZE];  <span class=\"comment\">//数组长度0x0c</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_boot</span> <span class=\"title\">uartDev</span>;</span></span><br></pre></td></tr></table></figure>\n<p>1.信息获取</p>\n<blockquote>\n<p>获取4字节数据</p>\n</blockquote>\n<p>2.同步(<code>&lt;2min</code>)</p>\n<blockquote>\n<p>将之前获取的数据与<code>0x73 79 6e 63</code>进行比较如果成功发送一个<code>ack</code>(<code>Response</code>)，<code>ack</code>成功时跳出循环<code>download_sync</code>成功。</p>\n</blockquote>\n<p>3.获取数据信息(<code>type，addr，len</code>)(<code>&lt;3sec</code>)</p>\n<blockquote>\n<p>获取12字节数据其中前四个代表数据模式，后面四个是地址，最后为数据长度（<code>&lt;32K</code>）。<br>生存时间增加<code>1sec</code>，回馈<code>ack</code>并进行下次信息获取直至模式不是<code>0x01</code>。</p>\n</blockquote>\n<p>4.获取数据(<code>&lt;5sec</code>)</p>\n<blockquote>\n<p>根据数据长度在指定地址获取数据(首地址<code>0x10000</code>)，一次最多读取长度为<code>0x400</code>。<br>每获取一次回馈一次<code>ack</code>，直至获取完成</p>\n</blockquote>\n<p>5.获取到<code>UBOOT</code>函数地址并以函数指针形式调用</p>\n<hr>\n<p>当模式为1时 启用<code>SDIO_BOOT</code></p>\n<p>1.初始化<code>SDIO</code></p>\n<blockquote>\n<p>使能时钟，将<code>CLK_EN_BASE</code>的第1位与第12位置1</p>\n</blockquote>\n<p><code>bootrom</code>-&gt;<code>uboot</code> 信息</p>\n","categories":[{"name":"bootrom","slug":"bootrom","count":2,"path":"api/categories/bootrom.json"}],"tags":[{"name":"bootrom","slug":"bootrom","count":3,"path":"api/tags/bootrom.json"}]}