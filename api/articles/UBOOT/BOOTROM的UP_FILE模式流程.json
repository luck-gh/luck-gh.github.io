{"title":"BOOTROM的UP_FILE模式流程","slug":"UBOOT/BOOTROM的UP_FILE模式流程","date":"2018-05-28T08:01:06.000Z","updated":"2018-10-21T08:33:45.695Z","comments":true,"path":"api/articles/UBOOT/BOOTROM的UP_FILE模式流程.json","photos":[],"link":"","excerpt":"BootRom是固化在芯片内部的一段代码，用于引导启动UBOOT，是开机启动的最重要阶段。","covers":null,"content":"<p>BootRom是固化在芯片内部的一段代码，用于引导启动UBOOT，是开机启动的最重要阶段。</p>\n<a id=\"more\"></a>\n<h1 id=\"BOOTROM\"><a href=\"#BOOTROM\" class=\"headerlink\" title=\"BOOTROM\"></a>BOOTROM</h1><h2 id=\"状态查询\"><a href=\"#状态查询\" class=\"headerlink\" title=\"状态查询\"></a>状态查询</h2><p>获取地址<code>BOOTMODE_BASE(0x00 60 18 08)</code>内的数据。<br>其中第零与第一位表示<code>bootrom</code>状态选择。</p>\n<blockquote>\n<p><code>=3</code><br>       FLIASH启动模式<br><code>=2</code><br>       UART下载模式<br><code>=1</code><br>       SDIO下载模式<br><code>=0 || 未定义</code><br>       片内无有效版本，启动失败</p>\n</blockquote>\n<h2 id=\"FLIASH启动模式\"><a href=\"#FLIASH启动模式\" class=\"headerlink\" title=\"FLIASH启动模式\"></a>FLIASH启动模式</h2><ul>\n<li>初始化 <code>spi filsh</code></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#define inw(reg)\t\t(*((volatile unsigned int *) (reg)))</span><br><span class=\"line\">/*</span><br><span class=\"line\">*  volatile修饰的是变化量故此 </span><br><span class=\"line\">*  ((volatile unsigned int)(*((unsigned int *) (reg))))</span><br><span class=\"line\">*/</span><br><span class=\"line\"></span><br><span class=\"line\">将PIN0_MUX_BASE(0x00 60 18 24)内的值</span><br><span class=\"line\">23~21位置为 011（PIN23(GPIO7)-DO   MUX CFG)</span><br><span class=\"line\">27~24位置为 011（PIN24(GPIO8)-DI   MUX CFG)\t</span><br><span class=\"line\">29~27位置为 011（PIN25(GPIO9)-HOLD MUX CFG)\t</span><br><span class=\"line\"></span><br><span class=\"line\">将PIN1_MUX_BASE(0x00 60 18 28)内的值</span><br><span class=\"line\">03~00位置为 011（PIN26(GPIO10)-WP  MUX CFG)</span><br><span class=\"line\">06~03位置为 011（PIN27(GPIO11)-CLK MUX CFG)\t</span><br><span class=\"line\">09~06位置为 011（PIN28(GPIO12)-CS0 MUX CFG)\t</span><br><span class=\"line\"></span><br><span class=\"line\">/*使能时钟*/</span><br><span class=\"line\">CLK_ENABLE(CLK_SPI_FLASH | CLK_SPI_FLASH_AHB);</span><br><span class=\"line\">CLK_ENBASE (0x00 60 18 0c) 第3位和第15位置1</span><br></pre></td></tr></table></figure>\n<ul>\n<li><p>芯片检查</p>\n<blockquote>\n<p>获取芯片码并将低八位置一写回<br>判断spirom是否可以读取成功不成功证明芯片有问题，结束flash_boot并返回1</p>\n</blockquote>\n</li>\n<li><p>检查<code>spi-flash</code>版本号</p>\n<blockquote>\n<p>用<code>spi</code>向<code>flash</code>发送指令读取<code>flash</code>的标签版本号，将<code>SPI-FLASH</code>中以<code>ENV_FLASH_BASE(0x0)</code>为起点大小为<code>0X100(256B)</code>的数据存入数据区<code>(DLM)</code>的内存顶部<code>(EDLM_BASE + EDLM_SIZE - ENV_INFO_SIZE)</code><br>判断之前的标签是否为”TS8266”如果是，则错误，结束flash_boot并返回1</p>\n</blockquote>\n</li>\n<li><p><code>CRC</code>校验</p>\n<blockquote>\n<p>成功时执行加载<code>SPI-FLASH</code>中的<code>UBOOT</code>到内存中，失败时结束<code>flash_boot</code>并返回<code>1</code></p>\n</blockquote>\n</li>\n<li><p>获取到<code>UBOOT</code>函数地址并以函数指针形式调用<br>当f<code>lash_boot</code>返回<code>1</code>时启用<code>UART_BOOT</code></p>\n</li>\n</ul>\n<h2 id=\"UART启动模式\"><a href=\"#UART启动模式\" class=\"headerlink\" title=\"UART启动模式\"></a>UART启动模式</h2><p>专用结构体</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_boot</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> time_count;  <span class=\"comment\">//生存时间的记录由10000 * 120递减</span></span><br><span class=\"line\">\t<span class=\"keyword\">char</span> tempBuf[CFG_MSG_SIZE];  <span class=\"comment\">//数组长度0x0c</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">uart_boot</span> <span class=\"title\">uartDev</span>;</span></span><br></pre></td></tr></table></figure>\n<p>1.信息获取</p>\n<blockquote>\n<p>获取4字节数据</p>\n</blockquote>\n<p>2.同步(<code>&lt;2min</code>)</p>\n<blockquote>\n<p>将之前获取的数据与<code>0x73 79 6e 63</code>进行比较如果成功发送一个<code>ack</code>(<code>Response</code>)，<code>ack</code>成功时跳出循环<code>download_sync</code>成功。</p>\n</blockquote>\n<p>3.获取数据信息(<code>type，addr，len</code>)(<code>&lt;3sec</code>)</p>\n<blockquote>\n<p>获取12字节数据其中前四个代表数据模式，后面四个是地址，最后为数据长度（<code>&lt;32K</code>）。<br>生存时间增加<code>1sec</code>，回馈<code>ack</code>并进行下次信息获取直至模式不是<code>0x01</code>。</p>\n</blockquote>\n<p>4.获取数据(<code>&lt;5sec</code>)</p>\n<blockquote>\n<p>根据数据长度在指定地址获取数据(首地址<code>0x10000</code>)，一次最多读取长度为<code>0x400</code>。<br>每获取一次回馈一次<code>ack</code>，直至获取完成</p>\n</blockquote>\n<p>5.获取到<code>UBOOT</code>函数地址并以函数指针形式调用</p>\n<h1 id=\"UBOOT\"><a href=\"#UBOOT\" class=\"headerlink\" title=\"UBOOT\"></a>UBOOT</h1>","categories":[{"name":"BOOT","slug":"BOOT","count":3,"path":"api/categories/BOOT.json"}],"tags":[{"name":"BOOT","slug":"BOOT","count":3,"path":"api/tags/BOOT.json"}]}