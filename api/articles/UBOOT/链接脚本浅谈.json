{"title":"连接脚本浅谈","slug":"UBOOT/链接脚本浅谈","date":"2018-05-26T03:54:32.000Z","updated":"2018-09-15T04:17:53.216Z","comments":true,"path":"api/articles/UBOOT/链接脚本浅谈.json","photos":[],"link":"","excerpt":"对于.lds文件，它定义了整个程序编译之后的连接过程，决定了一个可执行程序的各个段的存储位置。虽然现在我还没怎么用它，但感觉还是挺重要的，有必要了解一下。","covers":null,"content":"<p>对于<code>.lds</code>文件，它定义了整个程序编译之后的连接过程，决定了一个可执行程序的各个段的存储位置。虽然现在我还没怎么用它，但感觉还是挺重要的，有必要了解一下。</p>\n<a id=\"more\"></a>\n<h1 id=\"一、概论\"><a href=\"#一、概论\" class=\"headerlink\" title=\"一、概论\"></a>一、概论</h1><ul>\n<li>每一个链接过程<a href=\"编译四步：预处理、编译、汇编、链接\">^1.1</a>  都由<strong>链接脚本</strong>[^1.2]控制。<strong>链接脚本</strong>主要用于规定如何把输入文件内的<code>section</code>放入输出文件内，并控制输出文件内各部分在程序地址空间内的布局，但你也可以用连接命令做一些其他事情。</li>\n<li>连接器有个默认的内置连接脚本，可用<code>ld –verbose</code>查看，连接选项<code>-r</code>和<code>-N</code>可以影响默认的连接脚本 （如何影响？）。</li>\n<li><code>-T</code>选项用以指定自己的链接脚本，它将代替默认的连接脚本。你也可以使用以增加自定义的链接命令。</li>\n<li>以下没有特殊说明 , 连接器指的是静态连接器。</li>\n</ul>\n<p>[^1.2]: <code>linker script</code>, 一般以<code>lds</code>作为文件的后缀名</p>\n<h1 id=\"二、基本概念\"><a href=\"#二、基本概念\" class=\"headerlink\" title=\"二、基本概念\"></a>二、基本概念</h1><ul>\n<li>链接器把一个或多个输入文件合成一个输出文件.<blockquote>\n<p>输入文件 : 目标文件或链接脚本文件 . (是指连接的时候提供<code>LD</code>的所有目标文件 (<code>OBJ</code>二进制文件) 中的段 .)<br>输出文件 : 目标文件或可执行文件 . (是指生成的文件，例如 <code>elf</code> 中的每个段 .)</p>\n</blockquote>\n</li>\n<li>目标文件 ( 包括可执行文件 ) 具有固定的格式, 在<code>UNIX</code>或<code>GNU/Linux</code>平台下, 一般为<code>ELF</code>格式</li>\n<li>有时把输入文件内的<code>section</code>称为输入<code>section(input section)</code>, 把输出文件内的<code>section</code>称为输出<code>section(output sectin)</code>.</li>\n<li>目标文件的每个<code>section</code>至少包含两个信息 : 名字和大小. 大部分<code>section</code>还包含与它相关联的一块数据 , 称为<code>section contents(section内容)</code> . 一个<code>section</code>可被标记为 “<code>loadable</code>(可加载的) ” 或 “ <code>allocatable</code>(可分配的)”.</li>\n<li><code>loadable section</code> : 在输出文件运行时, 相应的section内容将被载入进程地址空间中.</li>\n<li><code>allocatable section</code> : 内容为空的<code>section</code>可被标记为 “ 可分配的 ”  .  在输出文件运行时, 在进程地址空间中空出大小同<code>section</code>指定大小的部分 .  某些情况下, 这块内存必须被置零.</li>\n<li>如果一个<code>section</code>不是“可加载的”或“可分配的”, 那么该<code>section</code>通常包含了调试信息. 可用<code>objdump -h</code>命令查看相关信息.</li>\n<li>每个 “ 可加载的 ” 或 “ 可分配的 ” 输出<code>section</code>通常包含两个地址: <code>VMA</code>(<code>virtual memory address</code>虚拟内存地址或程序地址空间地址 )  和<code>LMA</code>(<code>load memory address</code>加载内存地址或进程地址空间地址 )  .  通常<code>VMA</code>和<code>LMA</code>是相同的 .</li>\n<li>在目标文件中 , <code>loadable</code>或<code>allocatable</code>的输出<code>section</code>有两种地址 : <code>VMA</code>(<code>virtual Memory Address</code> )  和<code>LMA</code>(<code>Load Memory Address</code>) . <code>VMA</code>是执行输出文件时<code>section</code>所在的地址, 而<code>LMA</code>是加载输出文件时<code>section</code>所在的地址 . 一般而言 , 某<code>section</code>的<code>VMA == LMA</code> . 但在嵌入式系统中 , 经常存在加载地址和执行地址不同的情况 : 比如将输出文件加载到开发板的<code>flash</code>中 ( 由<code>LMA</code>指定 ) , 而在运行时将位于<code>flash</code>中的输出文件复制到<code>SDRAM</code>中 ( 由<code>VMA</code>指定 ) .</li>\n<li>可这样来理解<code>VMA</code>和<code>LMA</code> , 假设 :<blockquote>\n<p>(1) <code>.data section</code>对应的<code>VMA</code>地址是<code>0×08 05 00 00</code>, 该<code>section</code>内包含了3个32位全局变量 , <code>i</code>、<code>j</code>和<code>k</code>, 分别为1 , 2 , 3 .<br>(2)<code>.text section</code>内包含由<code>”printf( “j=%d “, j );”</code>程序片段产生的代码 .</p>\n</blockquote>\n</li>\n<li>连接时指定<code>.data section</code>的<code>VMA</code>为<code>0×08 05 00 00</code>, 产生的<code>printf</code>指令是将地址为<code>0×08 05 00 04</code>处的4字节内容作为一个整数打印出来.<blockquote>\n<p>如果<code>.data section</code>的<code>LMA</code>为<code>0×08 05 00 00</code>，显然结果是j=2<br>如果<code>.data section</code>的<code>LMA</code>为<code>0×08 05 00 04</code>，显然结果是j=1</p>\n</blockquote>\n</li>\n<li><p>还可这样理解<code>LMA</code>:<br><code>.text section</code>内容的开始处包含如下两条指令 ( <code>intel i386</code>指令是10字节，每行对应5字节 ) :</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">jmp 0×08048285`</span><br><span class=\"line\">movl $0×1,%eax</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果<code>.text section</code>的<code>LMA</code>为<code>0×08 04 82 80</code>, 那么在进程地址空间内<code>0×08 04 82 80</code>处为<code>“jmp 0×08 04 82 85”</code>指令 , <code>0×08 04 82 85</code>处为<code>movl $0×1,%eax</code>指令. 假</p>\n</li>\n<li>某指令跳转到地址<code>0×08 04 82 80</code>, 显然它的执行将导致<code>%eax</code>寄存器被赋值为1.</li>\n<li>如果<code>.text section</code>的<code>LMA</code>为<code>0×08 04 82 85</code>, 那么在进程地址空间内<code>0×08 04 82 85</code>处为<code>“jmp 0×08 04 82 85”</code>指令 , <code>0×08 04 82 8a</code>处为<code>movl $0×1,%eax</code>指令. 假设某指令跳转到地址<code>0×08 04 82 85</code>, 显然它的执行又跳转到进程地址空间内<code>0×08 04 82 85</code>处, 造成死循环.</li>\n<li>符号(<code>symbol</code>) : 每个目标文件都有符号表 (<code>SYMBOL TABLE</code>)  ,  包含已定义的符号 ( 对应全局变量和<code>static</code>变量和定义的函数的名字 ) 和未定义符号 ( 未定义的函数的名字和引用但没定义的符号 ) 信息 .</li>\n<li>符号值 :  每个符号对应一个地址 , 即符号值(这与c程序内变量的值不一样 , 某种情况下可以把它看成变量的地址 ). 可用<code>nm</code>命令查看它们. (<code>nm</code>的使用方法可参考本<code>blog</code>的<code>GNU binutils</code>笔记 )<h1 id=\"三、基本格式\"><a href=\"#三、基本格式\" class=\"headerlink\" title=\"三、基本格式\"></a>三、基本格式</h1></li>\n<li>链接脚本由一系列命令组成, 每个命令由一个关键字(一般在其后紧跟相关参数)或一条对符号的赋值语句组成. 命令由分号‘;’分隔开.</li>\n<li>文件名或格式名内如果包含分号’;’或其他分隔符, 则要用引号‘”’将名字全称引用起来. 无法处理含引号的文件名.<br>/<em> </em>/之间的是注释。<h1 id=\"四、基本架构\"><a href=\"#四、基本架构\" class=\"headerlink\" title=\"四、基本架构\"></a>四、基本架构</h1>##零<br>对符号的赋值<br>在目标文件内定义的符号可以在链接脚本内被赋值. (注意和C语言中赋值的不同!) 此时该符号被定义为全局的. 每个符号都对应了一个地址, 此处的赋值是更改这个符号对应的地址.<br>举例. 通过下面的程序查看变量a的地址:<br>a.c文件<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* a.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a = <span class=\"number\">100</span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>( <span class=\"string\">\"&amp;a=%p\\n\"</span>, &amp;a );</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>a.lds文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/* a.lds */</span><br><span class=\"line\">a = 3;</span><br></pre></td></tr></table></figure></p>\n<p>编译命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gcc -Wall -o a-without-lds.exe a.c</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;a = 0×601020</span><br></pre></td></tr></table></figure></p>\n<p>编译命令：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">$</span> gcc -Wall -o a-with-lds.exe a.c a.lds</span><br></pre></td></tr></table></figure></p>\n<p>运行结果：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&amp;a = 0×3</span><br></pre></td></tr></table></figure></p>\n<p><strong><em>注意: 对符号的赋值只对全局变量起作用</em></strong></p>\n<h2 id=\"壹\"><a href=\"#壹\" class=\"headerlink\" title=\"壹\"></a>壹</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OUTPUT_FORMAT(&quot;elf32-nds32&quot;, &quot;elf32-nds32&quot;, &quot;elf32-nds32&quot;)</span><br><span class=\"line\">OUTPUT_ARCH(nds32)</span><br></pre></td></tr></table></figure>\n<p>系统默认的关键字，指示系统可以有生成的格式。</p>\n<h2 id=\"贰\"><a href=\"#贰\" class=\"headerlink\" title=\"贰\"></a>贰</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ENTRY(_start)</span><br></pre></td></tr></table></figure>\n<p>指定入口点，<code>LD</code>的手册说，<code>ENTRY POINT</code> 就是程序第一条执行的指令，但是，说老实话，我并不理解，因为这里跟我的理解矛盾了，首先，通常情况，系统需要一个初始化的 <code>STARTUP.S</code>文件来初始化硬件，也就是<code>UBOOT</code>的第一阶段了。那么很自然，入口点需要设置在这段代码的第一条指令中，那么正常运行的时候从第一条指令开始运行。所以这里设置了<code>_start</code>为入口点，这个在汇编代码中必须得先 明一下为全局，才能用，否则系统找不到。例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.global  _start</span><br></pre></td></tr></table></figure></p>\n<p>但是问题是，如果我用同样的办法，设置另外一个不是第一条指令的入口点，<code>LD</code>并没有报错，但是问题来了，生成的文件和刚才设置入口点为 <code>__ENTRY</code> 的时候一模一 样，这就蒙了，到底这个入口点是怎么回事？<br>记得以前ADS的时候也碰到过 <code>entry point</code>的问题，下载仿真的时候确实是自动跳转 到 <code>entry point</code>中运行。<br>我想到的可能的原因，第一，生成 <code>elf</code> 文件并不是能直接用在嵌入式平台上面裸跑的，因为我们并没有操作系统，我们不需要elf文件头的那些指示信息提供给操作 系统，指示系统怎么去加载文件，在嵌入式上面的完全没有那个必要，只需要将实 际的代码提取出来，直接运行就OK，也就是 <code>objcopy</code>的操作，所以我觉得，在裸奔 的嵌入式系统上面，<code>entry point</code>是没有意义的，只需要指向整个代码最开始的指 令就OK了。<br>暂时我还是不能清晰的理解这个东西。先放下。以后碰到问题再分析。</p>\n<h2 id=\"叁\"><a href=\"#叁\" class=\"headerlink\" title=\"叁\"></a>叁</h2><p>一个输出段的标准格式<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SECTION [address] [(type)] : [AT(lma)]</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    OUTPUT-SECTIONS-COMMAND</span><br><span class=\"line\">    OUTPUT-SECTIONS-COMMAND</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125; [&gt;region] [AT&gt;ima_region] [:phdr :phdr ...] [=filexp]</span><br><span class=\"line\"></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tOUTPUT-SECTIONS-COMMAND</span><br><span class=\"line\">\tOUTPUT-SECTIONS-COMMAND</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>所谓的输出段(<code>section</code>)是指最终生成的文件里面的段，所以一个输出段就可以，<br>理解为最终文件里面的一个块，那么多个块合起来就是一个完成文件了。<br>而每个小块又分别有什么文件来组成呢？那就是输入段了。<br><code>OUTPUT-SECTION-COMMAND</code>有四种:<br>(1)<code>ENTRY</code>命令<br>(2) 符号赋值语句<br>(3) 一个输出<code>section</code>的描述(<code>output section description</code>)<br>(4) 一个<code>section</code>叠加描述(<code>overlay description</code>)<br>如果整个连接脚本内没有<code>SECTIONS</code>命令, 那么<code>ld</code>将所有同名输入<code>section</code>合成为一个输出<code>section</code>内, 各输入<code>section</code>的顺序为它们被连接器发现的顺序.如果某输入<code>section</code>没有在<code>SECTIONS</code>命令中提到, 那么该<code>section</code>将被直接拷贝成输出<code>section</code>。</p>\n</blockquote>\n<p>默认的4个段是必须有的<br><code>.text</code> : 代码<br><code>.rodata</code> : 常量（字符床之类的）<br><code>.data</code> : 初始化的全局变量<br><code>.bss</code> : 没有初始化的全局变量<br><strong><em>连接器依次扫描每个<code>OUTPUT-SECTION-COMMAND</code>命令内的文件名，任何一个文件的任何一个<code>section</code>都只能使用一次。</em></strong><br>段名字后面紧跟的是 vma ，也就是这个段在程序运行的时候的地址，例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text 0x30 00 00 00:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *(.text)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>表示的是代码的运行时地址为 <code>0x30 00 00 00</code> 假如你的<code>ROM</code>在 <code>0x0</code> 地址，程序放在<code>ROM</code>中，那个时候程序是不能正常运行的（位置无关代码除外），必须将代码<code>COPY</code>到<code>VMA</code>也就是 <code>0x30 00 00 00</code> 中才能正常运行。<br>至于那个 <code>AT(lma)</code> 的关键字，只指示代码连接的时候应该放在什么地方，注意好<br>这个英文是 <code>load memory address</code>，是指程序应该装载在什么地方，而不是指这个段 <br>应该在最后生成的<code>bin</code>文件的位置！！！这个东西蒙骗了我，让我郁闷了1天。<code>elf</code>格式的文件里面不但包含了代码，还包含了各种各样的信息，例如上面说的每个段的<code>lma</code> 和<code>vma</code>，还有其他信息都包含在里面了。<br>默认状态下，<code>lma</code> 是等于当前的<code>vma</code>的，例如 <br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text 0x30 00 00 00:</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *(.text)</span><br><span class=\"line\">    *(.rodata)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">.data 0x33 ff ff 00 :</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    *(.data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>另一种书写模式<br>以下脚本将输出文件的<code>text section</code>定位在<code>0×10000, data section</code>定位在<code>0×08 00 00 00</code>:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">. = 0×10000;</span><br><span class=\"line\">.text : &#123; *(.text) &#125;</span><br><span class=\"line\">. = 0×8000000;</span><br><span class=\"line\">.data : &#123; *(.data) &#125;</span><br><span class=\"line\">.bss : &#123; *(.bss) &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p><code>. = 0×01 00 00</code> : 把定位器符号置为<code>0×01 00 00</code>( 若不指定, 则该符号的初始值为0 );<br><code>.text : { *(.text) }</code>: 将所有(“*“符号代表任意输入文件)输入文件的<code>.text section</code>合并成一个<code>.text section</code>, 该<code>section</code>的地址由定位器符号的值指定, 即<code>0×01 00 00</code>;<br><code>. = 0×08 00 00 00</code>：把定位器符号置为<code>0×08 00 00 00</code>;<br><code>.data : { *(.data) }</code> : 将所有输入文件的<code>.data section</code>合并成一个<code>.data section</code>, 该<code>section</code>的地址被置为<code>0×08 00 00 00</code>;<br><code>.bss : { *(.bss) }</code> : 将所有输入文件的<code>.bss section</code>合并成一个<code>.bss section</code>，该<code>section</code>的地址被置为<code>0×08 00 00 00+.data section</code>的大小；<br>连接器每读完一个<code>section</code>描述后, 将定位器符号的值<strong>增加</strong>该<code>section</code>的大小。 注意: 此处没有考虑对齐约束。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OUTPUT_FORMAT(&quot;elf32-nds32&quot;, &quot;elf32-nds32&quot;, &quot;elf32-nds32&quot;)</span><br><span class=\"line\">OUTPUT_FORMAT(default, big, little)</span><br><span class=\"line\">//在链接的时候，如果使用了-EB的命令行参数，则使用这里的big参数指定</span><br><span class=\"line\">//的字节序，如果使用了-EL;的命令行参数，则使用这里的little参数指定</span><br><span class=\"line\">//的字节序，如果没有使用任何命令行参数，则使用这里的default参数指定</span><br><span class=\"line\">//的字节序。</span><br><span class=\"line\">//</span><br><span class=\"line\">//不管在链接的时候使用了何种命令行参数，输出的目标文件都是使用</span><br><span class=\"line\">//elf32-nds32方式的字节序。</span><br><span class=\"line\">//指定输出可执行文件是elf格式,32位nds32指令,</span><br><span class=\"line\"></span><br><span class=\"line\">OUTPUT_ARCH(nds32)</span><br><span class=\"line\">//指定输出可执行文件的平台为nds32</span><br><span class=\"line\"></span><br><span class=\"line\">ENTRY(_start)</span><br><span class=\"line\">//指定输出可执行文件的起始代码段为_start</span><br><span class=\"line\"></span><br><span class=\"line\">SECTIONS</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t. = 0x00000000                  //定位当前地址为0地址   </span><br><span class=\"line\">\t. = ALIGN(4); \t\t\t\t\t//代码以4字节对齐 </span><br><span class=\"line\">\t.text :\t\t\t\t\t\t\t//指定代码段</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\tarch/nds32/cpu/d1088/start.o\t(.text) </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//代码的第一个代码部分</span><br><span class=\"line\">\t\t*(.text)\t\t\t\t\t//其它代码部分</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t. = ALIGN(4);</span><br><span class=\"line\">\t.rodata : &#123; *(SORT_BY_ALIGNMENT(SORT_BY_NAME(.rodata*))) &#125;</span><br><span class=\"line\">\t\t\t\t\t\t\t//指定只读数据段</span><br><span class=\"line\">\t\t\t\t\t\t\t//在uboot/include/u-boot</span><br><span class=\"line\">\t\t\t\t\t\t\t///u-boot.lds.h</span><br><span class=\"line\">\t\t\t\t\t\t\t//文件定义SORT_BY_ALIGNMENT</span><br><span class=\"line\">\t\t\t\t\t\t\t//和SORT_BY_NAME</span><br><span class=\"line\">\t\t\t\t\t\t\t//#define SORT_BY_ALIGNMENT(x) x</span><br><span class=\"line\">\t\t\t\t\t\t\t//#define SORT_BY_NAME(x) x   </span><br><span class=\"line\"></span><br><span class=\"line\">\t. = ALIGN(4);</span><br><span class=\"line\">\t.data : &#123; *(.data*) &#125;\t\t\t////指定 读/写 数据段</span><br><span class=\"line\"></span><br><span class=\"line\">\t. = ALIGN(4);</span><br><span class=\"line\"></span><br><span class=\"line\">\t.got : &#123;\t\t\t\t\t\t//指定got段, got段式是</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//uboot自定义的一个段, 非</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//标准段</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t</span><br><span class=\"line\">\t\t__got_start = .;\t\t\t//__got_start赋值为当前</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//位置, </span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//即got段的开始位</span><br><span class=\"line\">\t\t *(.got.plt) *(.got)</span><br><span class=\"line\">\t\t__got_end = .;\t\t\t\t//把__got_end赋值为当前</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//位置,即got段的结束位置</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">\t. = .;</span><br><span class=\"line\">\t__u_boot_cmd_start = .;\t\t\t//把__u_boot_cmd_start\t</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//赋值为当前位置, 即起始位置   </span><br><span class=\"line\">\t.u_boot_cmd : &#123; *(.u_boot_cmd) &#125;//指定u_boot_cmd段, uboot</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//把所有的uboot命令放在该段.   </span><br><span class=\"line\">\t__u_boot_cmd_end = .;\t\t\t//把__u_boot_cmd_end赋值为</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//当前位置,即结束位置   </span><br><span class=\"line\"></span><br><span class=\"line\">\t. = ALIGN(4);</span><br><span class=\"line\"></span><br><span class=\"line\">\t_end = .;\t\t\t\t\t\t//把_end赋值为当前位置,</span><br><span class=\"line\">\t\t\t\t\t\t\t\t\t//即bss段的开始位</span><br><span class=\"line\"></span><br><span class=\"line\">\t.bss : &#123;\t\t\t\t\t\t//指定bss段</span><br><span class=\"line\">\t\t__bss_start = .;</span><br><span class=\"line\">\t\t*(.bss)</span><br><span class=\"line\">\t\t . = ALIGN(4);</span><br><span class=\"line\">\t\t__bss_end__ = .;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","categories":[{"name":"链接脚本","slug":"链接脚本","count":1,"path":"api/categories/链接脚本.json"}],"tags":[{"name":"链接脚本","slug":"链接脚本","count":1,"path":"api/tags/链接脚本.json"}]}