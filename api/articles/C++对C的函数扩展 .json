{"title":"07_C++对C的函数扩展","slug":"C++对C的函数扩展 ","date":"2017-04-18T07:20:56.000Z","updated":"2018-04-23T13:22:31.780Z","comments":true,"path":"api/articles/C++对C的函数扩展 .json","photos":[],"link":"","excerpt":"1 inline内联函数 √<br>2 默认参数<br>3 函数占位参数<br>4 默认参数和占位参数<br>5 函数重载（Overroad）","covers":null,"content":"<p><strong>1 inline内联函数</strong> √<br><strong>2 默认参数</strong><br><strong>3 函数占位参数</strong><br><strong>4 默认参数和占位参数</strong><br><strong>5 函数重载（Overroad）</strong></p>\n<a id=\"more\"></a>\n<h1 id=\"一-inline内联函数\"><a href=\"#一-inline内联函数\" class=\"headerlink\" title=\"一. inline内联函数\"></a>一. inline内联函数</h1><ul>\n<li>C++中的const常量可以替代宏常数定义，如：<br><code>const int A = 3;  #define A 3</code><br>C++中是否有解决方案替代宏代码片段呢？（替代宏代码片段就可以避免宏的副作用！）</li>\n<li>C++中推荐使用内联函数替代宏代码片段<br>C++中使用inline关键字声明内联函数</li>\n<li>内联函数声明时inline关键字必须和函数定义结合在一起，否则编译器会直接忽略内联请求。<br>//宏替换和函数调用区别<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"iostream\"</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MYFUNC(a, b) ((a) &lt; (b) ? (a) : (b))  </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">inline</span> <span class=\"keyword\">int</span> <span class=\"title\">myfunc</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span>  </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> a &lt; b ? a : b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> b = <span class=\"number\">3</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//int c = myfunc(++a, b);  //头疼系统</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> c = MYFUNC(++a, b);  </span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"a = %d\\n\"</span>, a); </span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"b = %d\\n\"</span>, b);</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">\"c = %d\\n\"</span>, c);</span><br><span class=\"line\"></span><br><span class=\"line\">system(<span class=\"string\">\"pause\"</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"注意-1：\"><a href=\"#注意-1：\" class=\"headerlink\" title=\"注意 1：\"></a>注意 1：</h2><ul>\n<li>声明必须和函数体的实现，写在一块(inline不能声明)<br>(可以声明但是编译器不一定当内联函数处理)</li>\n</ul>\n<h2 id=\"注意-2：\"><a href=\"#注意-2：\" class=\"headerlink\" title=\"注意 2：\"></a>注意 2：</h2><ul>\n<li>C++编译器可以将一个函数进行内联编译</li>\n<li>被C++编译器内联编译的函数叫做内联函数</li>\n<li>内联函数在最终生成的代码中是没有定义的</li>\n<li><strong><em>C++编译器直接将函数体插入在函数调用的地方</em></strong> </li>\n<li>内联函数没有普通函数调用时的额外开销(压栈，跳转，返回)</li>\n</ul>\n<h2 id=\"注意-3：\"><a href=\"#注意-3：\" class=\"headerlink\" title=\"注意 3：\"></a>注意 3：</h2><ul>\n<li>C++编译器不一定准许函数的内联请求！</li>\n</ul>\n<h2 id=\"注意-4：\"><a href=\"#注意-4：\" class=\"headerlink\" title=\"注意 4：\"></a>注意 4：</h2><ul>\n<li>内联函数是一种特殊的函数，具有普通函数的特征（参数检查，返回类型等）</li>\n<li>内联函数是对编译器的一种请求，因此编译器可能拒绝这种请求</li>\n<li>内联函数由 编译器处理，直接将编译后的函数体插入调用的地方</li>\n<li>宏代码片段 由预处理器处理， 进行简单的文本替换，没有任何编译过程</li>\n</ul>\n<h2 id=\"注意-5：\"><a href=\"#注意-5：\" class=\"headerlink\" title=\"注意 5：\"></a>注意 5：</h2><ul>\n<li>现代C++编译器能够进行编译优化，因此一些函数即使没有inline声明，也可能被编译器内联编译<br>  另外，一些现代C++编译器提供了扩展语法，能够对函数进行强制内联<br>  如：g++中的<code>__attribute__((always_inline))</code>属性</li>\n</ul>\n<h2 id=\"注意-6：\"><a href=\"#注意-6：\" class=\"headerlink\" title=\"注意 6：\"></a>注意 6：</h2><ul>\n<li>C++中内联编译的限制：</li>\n<li>不能存在任何形式的循环语句    </li>\n<li>不能存在过多的条件判断语句</li>\n<li>函数体不能过于庞大</li>\n<li>不能对函数进行取址操作</li>\n<li>函数内联声明必须在调用语句之前</li>\n</ul>\n<h2 id=\"注意-7：\"><a href=\"#注意-7：\" class=\"headerlink\" title=\"注意 7：\"></a>注意 7：</h2><ul>\n<li>编译器对于内联函数的限制并不是绝对的，内联函数相对于普通函数的优势只是省去了函数调用时压栈，跳转和返回的开销。<br>  因此，当函数体的执行开销远大于压栈，跳转和返回所用的开销时，那么内联将无意义。</li>\n</ul>\n<h2 id=\"结论：\"><a href=\"#结论：\" class=\"headerlink\" title=\"结论：\"></a>结论：</h2><ul>\n<li>结论：<br>1）内联函数在编译时直接将函数体插入函数调用的地方<br>2）inline只是一种请求，编译器不一定允许这种请求<br>3）内联函数省去了普通函数调用时压栈，跳转和返回的开销 </li>\n</ul>\n","categories":[{"name":"面向对象编程","slug":"面向对象编程","count":7,"path":"api/categories/面向对象编程.json"}],"tags":[{"name":"Cpp对C的扩展","slug":"Cpp对C的扩展","count":7,"path":"api/tags/Cpp对C的扩展.json"}]}