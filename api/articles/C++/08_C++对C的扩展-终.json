{"title":"08_C++对C的扩展-终","slug":"C++/08_C++对C的扩展-终","date":"2017-04-19T12:58:03.000Z","updated":"2018-04-23T16:19:15.427Z","comments":true,"path":"api/articles/C++/08_C++对C的扩展-终.json","photos":[],"link":"","excerpt":"1  C++语言对C语言扩充和增强的几点具体体现 √<br>2 C语言register关键字—最快的关键字 √","covers":null,"content":"<p><strong>1  C++语言对C语言扩充和增强的几点具体体现</strong> √<br><strong>2 C语言register关键字—最快的关键字</strong> √</p>\n<a id=\"more\"></a>\n<h1 id=\"一-C-语言对C语言扩充和增强的几点具体体现\"><a href=\"#一-C-语言对C语言扩充和增强的几点具体体现\" class=\"headerlink\" title=\"一. C++语言对C语言扩充和增强的几点具体体现\"></a>一. C++语言对C语言扩充和增强的几点具体体现</h1><h2 id=\"1-更加灵活的变量说明\"><a href=\"#1-更加灵活的变量说明\" class=\"headerlink\" title=\"1 更加灵活的变量说明\"></a>1 更加灵活的变量说明</h2><blockquote>\n<ul>\n<li>在传统的语言中，局部支量的说明必须集中放在执行代码的前面（早期C标准），数据说明语句和执行语句的混合将引起编译错误。而在C++中，可以在程序代码块的任何地方进行局部变量的说明。比如下面的代码在C语言中是不正的，在C++语言中却可以正常运行。<br><code>for(int i= 1: i &lt;= 100; i++);</code><br>这样做的好处是使变量的定义和它的使用集中在一起，意义一目了然。</li>\n</ul>\n</blockquote>\n<h2 id=\"2-更加严格的函数原型说明\"><a href=\"#2-更加严格的函数原型说明\" class=\"headerlink\" title=\"2 更加严格的函数原型说明\"></a>2 更加严格的函数原型说明</h2><blockquote>\n<ul>\n<li>C++摒弃了C语言对函数原型随意简化的方式，这种简化是许多C语言程序错误的根源。C++语言要求编程者为函数提供完整的原型，包括全部参数的类型和返回值得说明。<br>例如，有字符型和对精度类型两个参数、返回整型值的函数f，原型应该写为:<br><code>int f(char,doub1e);</code><br>而c语言中允许将这个原型写成：<br><code>f( );</code><br>在函数原型说明中，参数名可有可无，并且可以和函数定义中的参数名不一致。</li>\n</ul>\n</blockquote>\n<h2 id=\"3-增加了函数重戴机制\"><a href=\"#3-增加了函数重戴机制\" class=\"headerlink\" title=\"3 增加了函数重戴机制\"></a>3 增加了函数重戴机制</h2><blockquote>\n<ul>\n<li>重载就是程序语言领域的重要相念。常规语言中最典型的例子是 “+、-、*、/” 等各种算术运算符的重载，这些符号可以同时用来表示多种类型数据之间的运算，这种对一个名字或一个符号赋子多重意义的情况就叫重载。</li>\n<li>C++语言增加了C语言所没有的函数重载机制。对一个函數名可以给出多个函数定义，只要这些定义可以通过参数个数或类型的不同区别开来即可。</li>\n<li>C++还允许对系统中预先定义的运算符号进行重载，增加新的定义。这样做的优点是在今后对新定义类型的安量进行运算时，计算公式写起来方便自然。</li>\n</ul>\n</blockquote>\n<h2 id=\"4-函数缺省参数-参数初始化\"><a href=\"#4-函数缺省参数-参数初始化\" class=\"headerlink\" title=\"4 函数缺省参数(参数初始化)\"></a>4 函数缺省参数(参数初始化)</h2><blockquote>\n<p>C++中允许函数有缺省参数，所谓缺省，是指参数调用时可以不给出实际的参数值。下面是一个有缺省参数的函数定义的实例：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">f</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b = <span class=\"number\">1</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a * b;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//此后，调用函数`f(3,1)`与`f(3)`效果相同。(因为第二个参数为1，与初始值相同)</span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"5-输入-输出流机制\"><a href=\"#5-输入-输出流机制\" class=\"headerlink\" title=\"5 输入/输出流机制\"></a>5 输入/输出流机制</h2><blockquote>\n<p>C++保留了C语言标准库中各种输入/输出函数，并且提供了一套新的输入/输出机制–流机制。<br>比如向标准输出输出一个字符串：<br><code>cout &lt;&lt; &quot;c++ is beautiful&quot;;</code><br>或者由标准输入读入一个整数，付给变量a：<br><code>int a;cin &gt;&gt; a;</code><br>流式输入/输出运算符能够根据变量类型自动确定数据的变换过程中的转换方式，还可以 定义<code>&quot;&lt;&lt;&quot;</code> ,<code>&quot;&gt;&gt;&quot;</code>的重载，方便了编程者自定义类型的数据输入/输出。</p>\n</blockquote>\n<h2 id=\"6-作用域限定运算符\"><a href=\"#6-作用域限定运算符\" class=\"headerlink\" title=\"6 作用域限定运算符\"></a>6 作用域限定运算符</h2><blockquote>\n<p>作用域限定运算符”<code>::</code>“用于对当前作用域外的同名变量进行访问。例如下面的例子中，我们可以利用”<code>::</code>“ 实现在局部变量a的作用域范围内的全局变量a的访问。<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> a;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> a;</span><br><span class=\"line\">    a = <span class=\"number\">3.14</span>;</span><br><span class=\"line\">    ::a = <span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"local  variable a = \"</span> &lt;&lt;   a &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"glocal variable a = \"</span> &lt;&lt; ::a &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//执行结果如下：</span></span><br><span class=\"line\"><span class=\"comment\">//local  variable a = 3.14</span></span><br><span class=\"line\"><span class=\"comment\">//glocal variable a = 6</span></span><br><span class=\"line\">&gt;</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h1 id=\"二-C语言register关键字—最快的关键字\"><a href=\"#二-C语言register关键字—最快的关键字\" class=\"headerlink\" title=\"二. C语言register关键字—最快的关键字\"></a>二. C语言register关键字—最快的关键字</h1><ul>\n<li>register：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率。注意是尽可能，不是绝对。你想想，一个CPU 的寄存器也就那么几个或几十个，你要是定义了很多很多register 变量，它累死也可能不能全部把这些变量放入寄存器吧，轮也可能轮不到你。</li>\n</ul>\n<h2 id=\"1-什么是寄存器\"><a href=\"#1-什么是寄存器\" class=\"headerlink\" title=\"1 什么是寄存器\"></a>1 什么是寄存器</h2><blockquote>\n<ul>\n<li>百度百科：寄存器，是集成电路中非常重要的一种存储单元，通常由触发器组成。在集成电路设计中，寄存器可分为电路内部使用的寄存器和充当内外部接口的寄存器这两类。内部寄存器不能被外部电路或软件访问，只是为内部电路的实现存储功能或满足电路的时序要求。而接口寄存器可以同时被内部电路和外部电路或软件访问，CPU中的寄存器就是其中一种，作为软硬件的接口，为广泛的通用编程用户所熟知。</li>\n<li>数据从内存里拿出来先放到寄存器，然后CPU 再从寄存器里读取数据来处理，处理完后同样把数据通过寄存器存放到内存里，<strong>CPU 不直接和内存打交道。因为速度快</strong></li>\n</ul>\n</blockquote>\n<h2 id=\"2-举例\"><a href=\"#2-举例\" class=\"headerlink\" title=\"2 举例\"></a>2 举例</h2><blockquote>\n<p><strong><em>register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。</em></strong><br>例如下面的内存块拷贝代码：<br><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">ifdef</span> NOSTRUCTASSIGN</span></span><br><span class=\"line\">\t<span class=\"built_in\">memcpy</span> (d, s, l) &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">register</span> <span class=\"keyword\">char</span> *d;</span><br><span class=\"line\">\t\t<span class=\"keyword\">register</span> <span class=\"keyword\">char</span> *s;</span><br><span class=\"line\">\t\t<span class=\"keyword\">register</span> <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> (i--)</span><br><span class=\"line\">\t\t*d++ = *s++;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">endif</span></span></span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<h2 id=\"3-使用register-修饰符的注意点\"><a href=\"#3-使用register-修饰符的注意点\" class=\"headerlink\" title=\"3 使用register 修饰符的注意点\"></a>3 使用register 修饰符的注意点</h2><blockquote>\n<p><strong>但是使用register修饰符有几点限制。</strong></p>\n<ul>\n<li>首先，<strong><code>register</code> 变量必须是能被CPU所接受的类型<em>。这通常意味着<code>register</code>变量</em> 必须是一个单个的值，<em>并且</em>长度应该小于或者等于整型的长度。</strong>不过，有些机器的寄存器也能存放浮点数。</li>\n<li>其次，因为<code>register</code>变量可能不存放在内存中，所以<strong><em>不能用“&amp;”来获取<code>register</code>变量的地址。</em></strong></li>\n<li>由于寄存器的数量有限，而且某些寄存器只能接受特定类型的数据（如指针和浮点数），因此真正起作用的<code>register</code>修饰符的数目和类型都依赖于运行程序的机器，而任何多余的<code>register</code>修饰符都将被编译程序所忽略。</li>\n<li>在某些情况下，把变量保存在寄存器中反而会降低程序的运行速度。因为<strong><em>被占用的寄存器不能再用于其它目的；</em></strong>或者<strong><em>变量被使用的次数不够多，不足以装入和存储变量所带来的额外开销。</em></strong></li>\n<li>早期的C编译程序不会把变量保存在寄存器中，除非你命令它这样做，这时<code>register</code>修饰符是C语言的一种很有价值的补充。然而，<strong>随着编译程序设计技术的进步，在决定那些变量应该被存到寄存器中时，现在的C编译环境能比程序员做出更好的决定。</strong>实际上，许多编译程序都会忽略<code>register</code>修饰符，因为尽管它完全合法，但<strong>它仅仅<em>是暗示而不是命令。</em></strong></li>\n</ul>\n</blockquote>\n","categories":[{"name":"面向对象编程","slug":"面向对象编程","count":8,"path":"api/categories/面向对象编程.json"}],"tags":[{"name":"Cpp对C的扩展","slug":"Cpp对C的扩展","count":8,"path":"api/tags/Cpp对C的扩展.json"}]}